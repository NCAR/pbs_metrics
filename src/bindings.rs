#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
/* automatically generated by rust-bindgen 0.60.1 */

pub const PBSE_DONOTUSE1: u32 = 15360;
pub const PBSE_DONOTUSE2: u32 = 15616;
pub const PBSE_DONOTUSE3: u32 = 15872;
pub const PBSE_DONOTUSE4: u32 = 16128;
pub const PBSE_DONOTUSE5: u32 = 16384;
pub const PBSE_: u32 = 15000;
pub const PBSE_NONE: u32 = 0;
pub const PBSE_UNKJOBID: u32 = 15001;
pub const PBSE_NOATTR: u32 = 15002;
pub const PBSE_ATTRRO: u32 = 15003;
pub const PBSE_IVALREQ: u32 = 15004;
pub const PBSE_UNKREQ: u32 = 15005;
pub const PBSE_TOOMANY: u32 = 15006;
pub const PBSE_PERM: u32 = 15007;
pub const PBSE_BADHOST: u32 = 15008;
pub const PBSE_JOBEXIST: u32 = 15009;
pub const PBSE_SYSTEM: u32 = 15010;
pub const PBSE_INTERNAL: u32 = 15011;
pub const PBSE_REGROUTE: u32 = 15012;
pub const PBSE_UNKSIG: u32 = 15013;
pub const PBSE_BADATVAL: u32 = 15014;
pub const PBSE_MODATRRUN: u32 = 15015;
pub const PBSE_BADSTATE: u32 = 15016;
pub const PBSE_UNKQUE: u32 = 15018;
pub const PBSE_BADCRED: u32 = 15019;
pub const PBSE_EXPIRED: u32 = 15020;
pub const PBSE_QUNOENB: u32 = 15021;
pub const PBSE_QACESS: u32 = 15022;
pub const PBSE_BADUSER: u32 = 15023;
pub const PBSE_HOPCOUNT: u32 = 15024;
pub const PBSE_QUEEXIST: u32 = 15025;
pub const PBSE_ATTRTYPE: u32 = 15026;
pub const PBSE_OBJBUSY: u32 = 15027;
pub const PBSE_QUENBIG: u32 = 15028;
pub const PBSE_NOSUP: u32 = 15029;
pub const PBSE_QUENOEN: u32 = 15030;
pub const PBSE_PROTOCOL: u32 = 15031;
pub const PBSE_BADATLST: u32 = 15032;
pub const PBSE_NOCONNECTS: u32 = 15033;
pub const PBSE_NOSERVER: u32 = 15034;
pub const PBSE_UNKRESC: u32 = 15035;
pub const PBSE_EXCQRESC: u32 = 15036;
pub const PBSE_QUENODFLT: u32 = 15037;
pub const PBSE_NORERUN: u32 = 15038;
pub const PBSE_ROUTEREJ: u32 = 15039;
pub const PBSE_ROUTEEXPD: u32 = 15040;
pub const PBSE_MOMREJECT: u32 = 15041;
pub const PBSE_BADSCRIPT: u32 = 15042;
pub const PBSE_STAGEIN: u32 = 15043;
pub const PBSE_RESCUNAV: u32 = 15044;
pub const PBSE_BADGRP: u32 = 15045;
pub const PBSE_MAXQUED: u32 = 15046;
pub const PBSE_CKPBSY: u32 = 15047;
pub const PBSE_EXLIMIT: u32 = 15048;
pub const PBSE_BADACCT: u32 = 15049;
pub const PBSE_ALRDYEXIT: u32 = 15050;
pub const PBSE_NOCOPYFILE: u32 = 15051;
pub const PBSE_CLEANEDOUT: u32 = 15052;
pub const PBSE_NOSYNCMSTR: u32 = 15053;
pub const PBSE_BADDEPEND: u32 = 15054;
pub const PBSE_DUPLIST: u32 = 15055;
pub const PBSE_DISPROTO: u32 = 15056;
pub const PBSE_EXECTHERE: u32 = 15057;
pub const PBSE_SISREJECT: u32 = 15058;
pub const PBSE_SISCOMM: u32 = 15059;
pub const PBSE_SVRDOWN: u32 = 15060;
pub const PBSE_CKPSHORT: u32 = 15061;
pub const PBSE_UNKNODE: u32 = 15062;
pub const PBSE_UNKNODEATR: u32 = 15063;
pub const PBSE_NONODES: u32 = 15064;
pub const PBSE_NODENBIG: u32 = 15065;
pub const PBSE_NODEEXIST: u32 = 15066;
pub const PBSE_BADNDATVAL: u32 = 15067;
pub const PBSE_MUTUALEX: u32 = 15068;
pub const PBSE_GMODERR: u32 = 15069;
pub const PBSE_NORELYMOM: u32 = 15070;
pub const PBSE_NOTSNODE: u32 = 15071;
pub const PBSE_RESV_NO_WALLTIME: u32 = 15075;
pub const PBSE_JOBNOTRESV: u32 = 15076;
pub const PBSE_TOOLATE: u32 = 15077;
pub const PBSE_IRESVE: u32 = 15078;
pub const PBSE_UNKRESVTYPE: u32 = 15079;
pub const PBSE_RESVEXIST: u32 = 15080;
pub const PBSE_resvFail: u32 = 15081;
pub const PBSE_genBatchReq: u32 = 15082;
pub const PBSE_mgrBatchReq: u32 = 15083;
pub const PBSE_UNKRESVID: u32 = 15084;
pub const PBSE_delProgress: u32 = 15085;
pub const PBSE_BADTSPEC: u32 = 15086;
pub const PBSE_RESVMSG: u32 = 15087;
pub const PBSE_NOTRESV: u32 = 15088;
pub const PBSE_BADNODESPEC: u32 = 15089;
pub const PBSE_LICENSECPU: u32 = 15090;
pub const PBSE_LICENSEINV: u32 = 15091;
pub const PBSE_RESVAUTH_H: u32 = 15092;
pub const PBSE_RESVAUTH_G: u32 = 15093;
pub const PBSE_RESVAUTH_U: u32 = 15094;
pub const PBSE_R_UID: u32 = 15095;
pub const PBSE_R_GID: u32 = 15096;
pub const PBSE_IBMSPSWITCH: u32 = 15097;
pub const PBSE_LICENSEUNAV: u32 = 15098;
pub const PBSE_NOSCHEDULER: u32 = 15099;
pub const PBSE_RESCNOTSTR: u32 = 15100;
pub const PBSE_MaxArraySize: u32 = 15107;
pub const PBSE_INVALSELECTRESC: u32 = 15108;
pub const PBSE_INVALJOBRESC: u32 = 15109;
pub const PBSE_INVALNODEPLACE: u32 = 15110;
pub const PBSE_PLACENOSELECT: u32 = 15111;
pub const PBSE_INDIRECTHOP: u32 = 15112;
pub const PBSE_INDIRECTBT: u32 = 15113;
pub const PBSE_NGBLUEGENE: u32 = 15114;
pub const PBSE_NODESTALE: u32 = 15115;
pub const PBSE_DUPRESC: u32 = 15116;
pub const PBSE_CONNFULL: u32 = 15117;
pub const PBSE_LICENSE_MIN_BADVAL: u32 = 15118;
pub const PBSE_LICENSE_MAX_BADVAL: u32 = 15119;
pub const PBSE_LICENSE_LINGER_BADVAL: u32 = 15120;
pub const PBSE_LICENSE_SERVER_DOWN: u32 = 15121;
pub const PBSE_LICENSE_BAD_ACTION: u32 = 15122;
pub const PBSE_BAD_FORMULA: u32 = 15123;
pub const PBSE_BAD_FORMULA_KW: u32 = 15124;
pub const PBSE_BAD_FORMULA_TYPE: u32 = 15125;
pub const PBSE_BAD_RRULE_YEARLY: u32 = 15126;
pub const PBSE_BAD_RRULE_MONTHLY: u32 = 15127;
pub const PBSE_BAD_RRULE_WEEKLY: u32 = 15128;
pub const PBSE_BAD_RRULE_DAILY: u32 = 15129;
pub const PBSE_BAD_RRULE_HOURLY: u32 = 15130;
pub const PBSE_BAD_RRULE_MINUTELY: u32 = 15131;
pub const PBSE_BAD_RRULE_SECONDLY: u32 = 15132;
pub const PBSE_BAD_RRULE_SYNTAX: u32 = 15133;
pub const PBSE_BAD_RRULE_SYNTAX2: u32 = 15134;
pub const PBSE_BAD_ICAL_TZ: u32 = 15135;
pub const PBSE_HOOKERROR: u32 = 15136;
pub const PBSE_NEEDQUET: u32 = 15137;
pub const PBSE_ETEERROR: u32 = 15138;
pub const PBSE_HISTJOBID: u32 = 15139;
pub const PBSE_JOBHISTNOTSET: u32 = 15140;
pub const PBSE_MIXENTLIMS: u32 = 15141;
pub const PBSE_ENTLIMCT: u32 = 15142;
pub const PBSE_ENTLIMRESC: u32 = 15143;
pub const PBSE_ATVALERANGE: u32 = 15144;
pub const PBSE_PROV_HEADERROR: u32 = 15145;
pub const PBSE_NODEPROV_NOACTION: u32 = 15146;
pub const PBSE_NODEPROV: u32 = 15147;
pub const PBSE_NODEPROV_NODEL: u32 = 15148;
pub const PBSE_NODE_BAD_CURRENT_AOE: u32 = 15149;
pub const PBSE_NOLOOPBACKIF: u32 = 15153;
pub const PBSE_IVAL_AOECHUNK: u32 = 15155;
pub const PBSE_JOBINRESV_CONFLICT: u32 = 15156;
pub const PBSE_NORUNALTEREDJOB: u32 = 15157;
pub const PBSE_HISTJOBDELETED: u32 = 15158;
pub const PBSE_NOHISTARRAYSUBJOB: u32 = 15159;
pub const PBSE_FORCE_QSUB_UPDATE: u32 = 15160;
pub const PBSE_SAVE_ERR: u32 = 15161;
pub const PBSE_MAX_NO_MINWT: u32 = 15162;
pub const PBSE_MIN_GT_MAXWT: u32 = 15163;
pub const PBSE_NOSTF_RESV: u32 = 15164;
pub const PBSE_NOSTF_JOBARRAY: u32 = 15165;
pub const PBSE_NOLIMIT_RESOURCE: u32 = 15166;
pub const PBSE_MOM_INCOMPLETE_HOOK: u32 = 15167;
pub const PBSE_MOM_REJECT_ROOT_SCRIPTS: u32 = 15168;
pub const PBSE_HOOK_REJECT: u32 = 15169;
pub const PBSE_HOOK_REJECT_RERUNJOB: u32 = 15170;
pub const PBSE_HOOK_REJECT_DELETEJOB: u32 = 15171;
pub const PBSE_IVAL_OBJ_NAME: u32 = 15172;
pub const PBSE_JOBNBIG: u32 = 15173;
pub const PBSE_RESCBUSY: u32 = 15174;
pub const PBSE_JOBSCRIPTMAXSIZE: u32 = 15175;
pub const PBSE_BADJOBSCRIPTMAXSIZE: u32 = 15176;
pub const PBSE_WRONG_RESUME: u32 = 15177;
pub const PBSE_RESV_NOT_EMPTY: u32 = 15178;
pub const PBSE_STDG_RESV_OCCR_CONFLICT: u32 = 15179;
pub const PBSE_SOFTWT_STF: u32 = 15180;
pub const PBSE_RESV_FROM_RESVJOB: u32 = 15181;
pub const PBSE_RESV_FROM_ARRJOB: u32 = 15182;
pub const PBSE_SELECT_NOT_SUBSET: u32 = 15183;
pub const PBSE_RMUNKNOWN: u32 = 15201;
pub const PBSE_RMBADPARAM: u32 = 15202;
pub const PBSE_RMNOPARAM: u32 = 15203;
pub const PBSE_RMEXIST: u32 = 15204;
pub const PBSE_RMSYSTEM: u32 = 15205;
pub const PBSE_RMPART: u32 = 15206;
pub const RM_ERR_UNKNOWN: u32 = 15201;
pub const RM_ERR_BADPARAM: u32 = 15202;
pub const RM_ERR_NOPARAM: u32 = 15203;
pub const RM_ERR_EXIST: u32 = 15204;
pub const RM_ERR_SYSTEM: u32 = 15205;
pub const PBSE_TRYAGAIN: u32 = 15208;
pub const PBSE_ALPSRELERR: u32 = 15209;
pub const PBSE_JOB_MOVED: u32 = 15210;
pub const PBSE_SCHEDEXIST: u32 = 15211;
pub const PBSE_SCHED_NAME_BIG: u32 = 15212;
pub const PBSE_UNKSCHED: u32 = 15213;
pub const PBSE_SCHED_NO_DEL: u32 = 15214;
pub const PBSE_SCHED_PRIV_EXIST: u32 = 15215;
pub const PBSE_SCHED_LOG_EXIST: u32 = 15216;
pub const PBSE_ROUTE_QUE_NO_PARTITION: u32 = 15217;
pub const PBSE_CANNOT_SET_ROUTE_QUE: u32 = 15218;
pub const PBSE_QUE_NOT_IN_PARTITION: u32 = 15219;
pub const PBSE_PARTITION_NOT_IN_QUE: u32 = 15220;
pub const PBSE_INVALID_PARTITION_QUE: u32 = 15221;
pub const PBSE_ALPS_SWITCH_ERR: u32 = 15222;
pub const PBSE_SCHED_OP_NOT_PERMITTED: u32 = 15223;
pub const PBSE_SCHED_PARTITION_ALREADY_EXISTS: u32 = 15224;
pub const PBSE_INVALID_MAX_JOB_SEQUENCE_ID: u32 = 15225;
pub const PBSE_SVR_SCHED_JSF_INCOMPAT: u32 = 15226;
pub const PBSE_NODE_BUSY: u32 = 15227;
pub const PBSE_DEFAULT_PARTITION: u32 = 15228;
pub const PBSE_HISTDEPEND: u32 = 15229;
pub const PBSE_NOTARRAY_ATTR: u32 = 15231;
pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const __USE_ANSI: u32 = 1;
pub const _BSD_SOURCE: u32 = 1;
pub const _SVID_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_BSD: u32 = 1;
pub const __USE_SVID: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201103;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 17;
pub const __GLIBC_HAVE_LONG_LONG: u32 = 1;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const __FILE_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const _G_config_h: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCKS_PER_SEC: u32 = 1000000;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _XLOCALE_H: u32 = 1;
pub const TYPE_ATTR_READONLY: u32 = 1;
pub const TYPE_ATTR_PUBLIC: u32 = 2;
pub const TYPE_ATTR_INVISIBLE: u32 = 4;
pub const TYPE_ATTR_ALL: u32 = 7;
pub const ATTR_a: &[u8; 15usize] = b"Execution_Time\0";
pub const ATTR_c: &[u8; 11usize] = b"Checkpoint\0";
pub const ATTR_e: &[u8; 11usize] = b"Error_Path\0";
pub const ATTR_g: &[u8; 11usize] = b"group_list\0";
pub const ATTR_h: &[u8; 11usize] = b"Hold_Types\0";
pub const ATTR_j: &[u8; 10usize] = b"Join_Path\0";
pub const ATTR_J: &[u8; 24usize] = b"array_indices_submitted\0";
pub const ATTR_k: &[u8; 11usize] = b"Keep_Files\0";
pub const ATTR_l: &[u8; 14usize] = b"Resource_List\0";
pub const ATTR_l_orig: &[u8; 19usize] = b"Resource_List_orig\0";
pub const ATTR_l_acct: &[u8; 19usize] = b"Resource_List_acct\0";
pub const ATTR_m: &[u8; 12usize] = b"Mail_Points\0";
pub const ATTR_o: &[u8; 12usize] = b"Output_Path\0";
pub const ATTR_p: &[u8; 9usize] = b"Priority\0";
pub const ATTR_q: &[u8; 12usize] = b"destination\0";
pub const ATTR_R: &[u8; 13usize] = b"Remove_Files\0";
pub const ATTR_r: &[u8; 10usize] = b"Rerunable\0";
pub const ATTR_u: &[u8; 10usize] = b"User_List\0";
pub const ATTR_v: &[u8; 14usize] = b"Variable_List\0";
pub const ATTR_A: &[u8; 13usize] = b"Account_Name\0";
pub const ATTR_M: &[u8; 11usize] = b"Mail_Users\0";
pub const ATTR_N: &[u8; 9usize] = b"Job_Name\0";
pub const ATTR_S: &[u8; 16usize] = b"Shell_Path_List\0";
pub const ATTR_array_indices_submitted: &[u8; 24usize] = b"array_indices_submitted\0";
pub const ATTR_depend: &[u8; 7usize] = b"depend\0";
pub const ATTR_inter: &[u8; 12usize] = b"interactive\0";
pub const ATTR_sandbox: &[u8; 8usize] = b"sandbox\0";
pub const ATTR_stagein: &[u8; 8usize] = b"stagein\0";
pub const ATTR_stageout: &[u8; 9usize] = b"stageout\0";
pub const ATTR_resvTag: &[u8; 12usize] = b"reserve_Tag\0";
pub const ATTR_resv_start: &[u8; 14usize] = b"reserve_start\0";
pub const ATTR_resv_end: &[u8; 12usize] = b"reserve_end\0";
pub const ATTR_resv_duration: &[u8; 17usize] = b"reserve_duration\0";
pub const ATTR_resv_state: &[u8; 14usize] = b"reserve_state\0";
pub const ATTR_resv_substate: &[u8; 17usize] = b"reserve_substate\0";
pub const ATTR_resv_job: &[u8; 12usize] = b"reserve_job\0";
pub const ATTR_auth_u: &[u8; 17usize] = b"Authorized_Users\0";
pub const ATTR_auth_g: &[u8; 18usize] = b"Authorized_Groups\0";
pub const ATTR_auth_h: &[u8; 17usize] = b"Authorized_Hosts\0";
pub const ATTR_cred: &[u8; 5usize] = b"cred\0";
pub const ATTR_nodemux: &[u8; 17usize] = b"no_stdio_sockets\0";
pub const ATTR_umask: &[u8; 6usize] = b"umask\0";
pub const ATTR_block: &[u8; 6usize] = b"block\0";
pub const ATTR_convert: &[u8; 6usize] = b"qmove\0";
pub const ATTR_DefaultChunk: &[u8; 14usize] = b"default_chunk\0";
pub const ATTR_X11_cookie: &[u8; 19usize] = b"forward_x11_cookie\0";
pub const ATTR_X11_port: &[u8; 17usize] = b"forward_x11_port\0";
pub const ATTR_GUI: &[u8; 4usize] = b"gui\0";
pub const ATTR_max_run_subjobs: &[u8; 16usize] = b"max_run_subjobs\0";
pub const ATTR_resv_standing: &[u8; 17usize] = b"reserve_standing\0";
pub const ATTR_resv_count: &[u8; 14usize] = b"reserve_count\0";
pub const ATTR_resv_idx: &[u8; 14usize] = b"reserve_index\0";
pub const ATTR_resv_rrule: &[u8; 14usize] = b"reserve_rrule\0";
pub const ATTR_resv_execvnodes: &[u8; 19usize] = b"reserve_execvnodes\0";
pub const ATTR_resv_timezone: &[u8; 17usize] = b"reserve_timezone\0";
pub const ATTR_ctime: &[u8; 6usize] = b"ctime\0";
pub const ATTR_estimated: &[u8; 10usize] = b"estimated\0";
pub const ATTR_exechost: &[u8; 10usize] = b"exec_host\0";
pub const ATTR_exechost_acct: &[u8; 15usize] = b"exec_host_acct\0";
pub const ATTR_exechost_orig: &[u8; 15usize] = b"exec_host_orig\0";
pub const ATTR_exechost2: &[u8; 11usize] = b"exec_host2\0";
pub const ATTR_execvnode: &[u8; 11usize] = b"exec_vnode\0";
pub const ATTR_execvnode_acct: &[u8; 16usize] = b"exec_vnode_acct\0";
pub const ATTR_execvnode_deallocated: &[u8; 23usize] = b"exec_vnode_deallocated\0";
pub const ATTR_execvnode_orig: &[u8; 16usize] = b"exec_vnode_orig\0";
pub const ATTR_resv_nodes: &[u8; 11usize] = b"resv_nodes\0";
pub const ATTR_mtime: &[u8; 6usize] = b"mtime\0";
pub const ATTR_qtime: &[u8; 6usize] = b"qtime\0";
pub const ATTR_session: &[u8; 11usize] = b"session_id\0";
pub const ATTR_jobdir: &[u8; 7usize] = b"jobdir\0";
pub const ATTR_euser: &[u8; 6usize] = b"euser\0";
pub const ATTR_egroup: &[u8; 7usize] = b"egroup\0";
pub const ATTR_project: &[u8; 8usize] = b"project\0";
pub const ATTR_hashname: &[u8; 9usize] = b"hashname\0";
pub const ATTR_hopcount: &[u8; 10usize] = b"hop_count\0";
pub const ATTR_security: &[u8; 9usize] = b"security\0";
pub const ATTR_sched_hint: &[u8; 11usize] = b"sched_hint\0";
pub const ATTR_SchedSelect: &[u8; 12usize] = b"schedselect\0";
pub const ATTR_SchedSelect_orig: &[u8; 17usize] = b"schedselect_orig\0";
pub const ATTR_substate: &[u8; 9usize] = b"substate\0";
pub const ATTR_name: &[u8; 9usize] = b"Job_Name\0";
pub const ATTR_owner: &[u8; 10usize] = b"Job_Owner\0";
pub const ATTR_used: &[u8; 15usize] = b"resources_used\0";
pub const ATTR_used_acct: &[u8; 20usize] = b"resources_used_acct\0";
pub const ATTR_used_update: &[u8; 22usize] = b"resources_used_update\0";
pub const ATTR_relnodes_on_stageout: &[u8; 26usize] = b"release_nodes_on_stageout\0";
pub const ATTR_tolerate_node_failures: &[u8; 23usize] = b"tolerate_node_failures\0";
pub const ATTR_released: &[u8; 19usize] = b"resources_released\0";
pub const ATTR_rel_list: &[u8; 23usize] = b"resource_released_list\0";
pub const ATTR_state: &[u8; 10usize] = b"job_state\0";
pub const ATTR_queue: &[u8; 6usize] = b"queue\0";
pub const ATTR_server: &[u8; 7usize] = b"server\0";
pub const ATTR_maxrun: &[u8; 12usize] = b"max_running\0";
pub const ATTR_max_run: &[u8; 8usize] = b"max_run\0";
pub const ATTR_max_run_res: &[u8; 12usize] = b"max_run_res\0";
pub const ATTR_max_run_soft: &[u8; 13usize] = b"max_run_soft\0";
pub const ATTR_max_run_res_soft: &[u8; 17usize] = b"max_run_res_soft\0";
pub const ATTR_total: &[u8; 11usize] = b"total_jobs\0";
pub const ATTR_comment: &[u8; 8usize] = b"comment\0";
pub const ATTR_cookie: &[u8; 7usize] = b"cookie\0";
pub const ATTR_qrank: &[u8; 11usize] = b"queue_rank\0";
pub const ATTR_altid: &[u8; 7usize] = b"alt_id\0";
pub const ATTR_altid2: &[u8; 8usize] = b"alt_id2\0";
pub const ATTR_acct_id: &[u8; 14usize] = b"accounting_id\0";
pub const ATTR_array: &[u8; 6usize] = b"array\0";
pub const ATTR_array_id: &[u8; 9usize] = b"array_id\0";
pub const ATTR_array_index: &[u8; 12usize] = b"array_index\0";
pub const ATTR_array_state_count: &[u8; 18usize] = b"array_state_count\0";
pub const ATTR_array_indices_remaining: &[u8; 24usize] = b"array_indices_remaining\0";
pub const ATTR_etime: &[u8; 6usize] = b"etime\0";
pub const ATTR_gridname: &[u8; 9usize] = b"gridname\0";
pub const ATTR_refresh: &[u8; 21usize] = b"last_context_refresh\0";
pub const ATTR_ReqCredEnable: &[u8; 20usize] = b"require_cred_enable\0";
pub const ATTR_ReqCred: &[u8; 13usize] = b"require_cred\0";
pub const ATTR_runcount: &[u8; 10usize] = b"run_count\0";
pub const ATTR_run_version: &[u8; 12usize] = b"run_version\0";
pub const ATTR_stime: &[u8; 6usize] = b"stime\0";
pub const ATTR_pset: &[u8; 5usize] = b"pset\0";
pub const ATTR_executable: &[u8; 11usize] = b"executable\0";
pub const ATTR_Arglist: &[u8; 14usize] = b"argument_list\0";
pub const ATTR_version: &[u8; 12usize] = b"pbs_version\0";
pub const ATTR_eligible_time: &[u8; 14usize] = b"eligible_time\0";
pub const ATTR_accrue_type: &[u8; 12usize] = b"accrue_type\0";
pub const ATTR_sample_starttime: &[u8; 17usize] = b"sample_starttime\0";
pub const ATTR_job_kill_delay: &[u8; 15usize] = b"job_kill_delay\0";
pub const ATTR_topjob_ineligible: &[u8; 18usize] = b"topjob_ineligible\0";
pub const ATTR_submit_host: &[u8; 12usize] = b"Submit_Host\0";
pub const ATTR_cred_id: &[u8; 14usize] = b"credential_id\0";
pub const ATTR_security_context: &[u8; 17usize] = b"security_context\0";
pub const ATTR_cred_validity: &[u8; 20usize] = b"credential_validity\0";
pub const ATTR_history_timestamp: &[u8; 18usize] = b"history_timestamp\0";
pub const ATTR_create_resv_from_job: &[u8; 21usize] = b"create_resv_from_job\0";
pub const ATTR_stageout_status: &[u8; 16usize] = b"Stageout_status\0";
pub const ATTR_exit_status: &[u8; 12usize] = b"Exit_status\0";
pub const ATTR_submit_arguments: &[u8; 17usize] = b"Submit_arguments\0";
pub const ATTR_resv_name: &[u8; 13usize] = b"Reserve_Name\0";
pub const ATTR_resv_owner: &[u8; 14usize] = b"Reserve_Owner\0";
pub const ATTR_resv_type: &[u8; 13usize] = b"reserve_type\0";
pub const ATTR_resv_Tag: &[u8; 16usize] = b"reservation_Tag\0";
pub const ATTR_resv_ID: &[u8; 11usize] = b"reserve_ID\0";
pub const ATTR_resv_retry: &[u8; 14usize] = b"reserve_retry\0";
pub const ATTR_del_idle_time: &[u8; 17usize] = b"delete_idle_time\0";
pub const ATTR_aclgren: &[u8; 17usize] = b"acl_group_enable\0";
pub const ATTR_aclgroup: &[u8; 11usize] = b"acl_groups\0";
pub const ATTR_aclhten: &[u8; 16usize] = b"acl_host_enable\0";
pub const ATTR_aclhost: &[u8; 10usize] = b"acl_hosts\0";
pub const ATTR_aclhostmomsen: &[u8; 21usize] = b"acl_host_moms_enable\0";
pub const ATTR_acluren: &[u8; 16usize] = b"acl_user_enable\0";
pub const ATTR_acluser: &[u8; 10usize] = b"acl_users\0";
pub const ATTR_altrouter: &[u8; 11usize] = b"alt_router\0";
pub const ATTR_chkptmin: &[u8; 15usize] = b"checkpoint_min\0";
pub const ATTR_enable: &[u8; 8usize] = b"enabled\0";
pub const ATTR_fromroute: &[u8; 16usize] = b"from_route_only\0";
pub const ATTR_HasNodes: &[u8; 9usize] = b"hasnodes\0";
pub const ATTR_killdelay: &[u8; 11usize] = b"kill_delay\0";
pub const ATTR_maxgrprun: &[u8; 14usize] = b"max_group_run\0";
pub const ATTR_maxgrprunsoft: &[u8; 19usize] = b"max_group_run_soft\0";
pub const ATTR_maxque: &[u8; 13usize] = b"max_queuable\0";
pub const ATTR_max_queued: &[u8; 11usize] = b"max_queued\0";
pub const ATTR_max_queued_res: &[u8; 15usize] = b"max_queued_res\0";
pub const ATTR_queued_jobs_threshold: &[u8; 22usize] = b"queued_jobs_threshold\0";
pub const ATTR_queued_jobs_threshold_res: &[u8; 26usize] = b"queued_jobs_threshold_res\0";
pub const ATTR_maxuserrun: &[u8; 13usize] = b"max_user_run\0";
pub const ATTR_maxuserrunsoft: &[u8; 18usize] = b"max_user_run_soft\0";
pub const ATTR_qtype: &[u8; 11usize] = b"queue_type\0";
pub const ATTR_rescassn: &[u8; 19usize] = b"resources_assigned\0";
pub const ATTR_rescdflt: &[u8; 18usize] = b"resources_default\0";
pub const ATTR_rescmax: &[u8; 14usize] = b"resources_max\0";
pub const ATTR_rescmin: &[u8; 14usize] = b"resources_min\0";
pub const ATTR_rndzretry: &[u8; 17usize] = b"rendezvous_retry\0";
pub const ATTR_routedest: &[u8; 19usize] = b"route_destinations\0";
pub const ATTR_routeheld: &[u8; 16usize] = b"route_held_jobs\0";
pub const ATTR_routewait: &[u8; 19usize] = b"route_waiting_jobs\0";
pub const ATTR_routeretry: &[u8; 17usize] = b"route_retry_time\0";
pub const ATTR_routelife: &[u8; 15usize] = b"route_lifetime\0";
pub const ATTR_rsvexpdt: &[u8; 18usize] = b"reserved_expedite\0";
pub const ATTR_rsvsync: &[u8; 14usize] = b"reserved_sync\0";
pub const ATTR_start: &[u8; 8usize] = b"started\0";
pub const ATTR_count: &[u8; 12usize] = b"state_count\0";
pub const ATTR_number: &[u8; 12usize] = b"number_jobs\0";
pub const ATTR_jobscript_max_size: &[u8; 19usize] = b"jobscript_max_size\0";
pub const ATTR_SvrHost: &[u8; 12usize] = b"server_host\0";
pub const ATTR_aclroot: &[u8; 10usize] = b"acl_roots\0";
pub const ATTR_managers: &[u8; 9usize] = b"managers\0";
pub const ATTR_dfltque: &[u8; 14usize] = b"default_queue\0";
pub const ATTR_defnode: &[u8; 13usize] = b"default_node\0";
pub const ATTR_locsvrs: &[u8; 17usize] = b"location_servers\0";
pub const ATTR_logevents: &[u8; 11usize] = b"log_events\0";
pub const ATTR_logfile: &[u8; 9usize] = b"log_file\0";
pub const ATTR_mailfrom: &[u8; 10usize] = b"mail_from\0";
pub const ATTR_nodepack: &[u8; 10usize] = b"node_pack\0";
pub const ATTR_nodefailrq: &[u8; 18usize] = b"node_fail_requeue\0";
pub const ATTR_operators: &[u8; 10usize] = b"operators\0";
pub const ATTR_queryother: &[u8; 17usize] = b"query_other_jobs\0";
pub const ATTR_resccost: &[u8; 15usize] = b"resources_cost\0";
pub const ATTR_rescavail: &[u8; 20usize] = b"resources_available\0";
pub const ATTR_maxuserres: &[u8; 13usize] = b"max_user_res\0";
pub const ATTR_maxuserressoft: &[u8; 18usize] = b"max_user_res_soft\0";
pub const ATTR_maxgroupres: &[u8; 14usize] = b"max_group_res\0";
pub const ATTR_maxgroupressoft: &[u8; 19usize] = b"max_group_res_soft\0";
pub const ATTR_maxarraysize: &[u8; 15usize] = b"max_array_size\0";
pub const ATTR_PNames: &[u8; 7usize] = b"pnames\0";
pub const ATTR_schediteration: &[u8; 20usize] = b"scheduler_iteration\0";
pub const ATTR_scheduling: &[u8; 11usize] = b"scheduling\0";
pub const ATTR_status: &[u8; 13usize] = b"server_state\0";
pub const ATTR_syscost: &[u8; 12usize] = b"system_cost\0";
pub const ATTR_FlatUID: &[u8; 8usize] = b"flatuid\0";
pub const ATTR_ResvEnable: &[u8; 12usize] = b"resv_enable\0";
pub const ATTR_aclResvgren: &[u8; 22usize] = b"acl_resv_group_enable\0";
pub const ATTR_aclResvgroup: &[u8; 16usize] = b"acl_resv_groups\0";
pub const ATTR_aclResvhten: &[u8; 21usize] = b"acl_resv_host_enable\0";
pub const ATTR_aclResvhost: &[u8; 15usize] = b"acl_resv_hosts\0";
pub const ATTR_aclResvuren: &[u8; 21usize] = b"acl_resv_user_enable\0";
pub const ATTR_aclResvuser: &[u8; 15usize] = b"acl_resv_users\0";
pub const ATTR_NodeGroupEnable: &[u8; 18usize] = b"node_group_enable\0";
pub const ATTR_NodeGroupKey: &[u8; 15usize] = b"node_group_key\0";
pub const ATTR_dfltqdelargs: &[u8; 23usize] = b"default_qdel_arguments\0";
pub const ATTR_dfltqsubargs: &[u8; 23usize] = b"default_qsub_arguments\0";
pub const ATTR_rpp_retry: &[u8; 10usize] = b"rpp_retry\0";
pub const ATTR_rpp_highwater: &[u8; 14usize] = b"rpp_highwater\0";
pub const ATTR_pbs_license_info: &[u8; 17usize] = b"pbs_license_info\0";
pub const ATTR_license_min: &[u8; 16usize] = b"pbs_license_min\0";
pub const ATTR_license_max: &[u8; 16usize] = b"pbs_license_max\0";
pub const ATTR_license_linger: &[u8; 24usize] = b"pbs_license_linger_time\0";
pub const ATTR_license_count: &[u8; 14usize] = b"license_count\0";
pub const ATTR_job_sort_formula: &[u8; 17usize] = b"job_sort_formula\0";
pub const ATTR_EligibleTimeEnable: &[u8; 21usize] = b"eligible_time_enable\0";
pub const ATTR_resv_retry_time: &[u8; 19usize] = b"reserve_retry_time\0";
pub const ATTR_resv_retry_init: &[u8; 19usize] = b"reserve_retry_init\0";
pub const ATTR_JobHistoryEnable: &[u8; 19usize] = b"job_history_enable\0";
pub const ATTR_JobHistoryDuration: &[u8; 21usize] = b"job_history_duration\0";
pub const ATTR_max_concurrent_prov: &[u8; 25usize] = b"max_concurrent_provision\0";
pub const ATTR_resv_post_processing: &[u8; 26usize] = b"resv_post_processing_time\0";
pub const ATTR_backfill_depth: &[u8; 15usize] = b"backfill_depth\0";
pub const ATTR_job_requeue_timeout: &[u8; 20usize] = b"job_requeue_timeout\0";
pub const ATTR_show_hidden_attribs: &[u8; 20usize] = b"show_hidden_attribs\0";
pub const ATTR_python_restart_max_hooks: &[u8; 25usize] = b"python_restart_max_hooks\0";
pub const ATTR_python_restart_max_objects: &[u8; 27usize] = b"python_restart_max_objects\0";
pub const ATTR_python_restart_min_interval: &[u8; 28usize] = b"python_restart_min_interval\0";
pub const ATTR_power_provisioning: &[u8; 19usize] = b"power_provisioning\0";
pub const ATTR_sync_mom_hookfiles_timeout: &[u8; 27usize] = b"sync_mom_hookfiles_timeout\0";
pub const ATTR_max_job_sequence_id: &[u8; 20usize] = b"max_job_sequence_id\0";
pub const ATTR_acl_krb_realm_enable: &[u8; 21usize] = b"acl_krb_realm_enable\0";
pub const ATTR_acl_krb_realms: &[u8; 15usize] = b"acl_krb_realms\0";
pub const ATTR_acl_krb_submit_realms: &[u8; 22usize] = b"acl_krb_submit_realms\0";
pub const ATTR_cred_renew_enable: &[u8; 18usize] = b"cred_renew_enable\0";
pub const ATTR_cred_renew_tool: &[u8; 16usize] = b"cred_renew_tool\0";
pub const ATTR_cred_renew_period: &[u8; 18usize] = b"cred_renew_period\0";
pub const ATTR_cred_renew_cache_period: &[u8; 24usize] = b"cred_renew_cache_period\0";
pub const ATTR_rpp_max_pkt_check: &[u8; 18usize] = b"rpp_max_pkt_check\0";
pub const ATTR_SchedHost: &[u8; 11usize] = b"sched_host\0";
pub const ATTR_sched_cycle_len: &[u8; 19usize] = b"sched_cycle_length\0";
pub const ATTR_do_not_span_psets: &[u8; 18usize] = b"do_not_span_psets\0";
pub const ATTR_only_explicit_psets: &[u8; 20usize] = b"only_explicit_psets\0";
pub const ATTR_sched_preempt_enforce_resumption: &[u8; 33usize] =
    b"sched_preempt_enforce_resumption\0";
pub const ATTR_preempt_targets_enable: &[u8; 23usize] = b"preempt_targets_enable\0";
pub const ATTR_job_sort_formula_threshold: &[u8; 27usize] = b"job_sort_formula_threshold\0";
pub const ATTR_throughput_mode: &[u8; 16usize] = b"throughput_mode\0";
pub const ATTR_opt_backfill_fuzzy: &[u8; 19usize] = b"opt_backfill_fuzzy\0";
pub const ATTR_sched_port: &[u8; 11usize] = b"sched_port\0";
pub const ATTR_partition: &[u8; 10usize] = b"partition\0";
pub const ATTR_sched_priv: &[u8; 11usize] = b"sched_priv\0";
pub const ATTR_sched_log: &[u8; 10usize] = b"sched_log\0";
pub const ATTR_sched_user: &[u8; 11usize] = b"sched_user\0";
pub const ATTR_sched_state: &[u8; 6usize] = b"state\0";
pub const ATTR_sched_preempt_queue_prio: &[u8; 19usize] = b"preempt_queue_prio\0";
pub const ATTR_sched_preempt_prio: &[u8; 13usize] = b"preempt_prio\0";
pub const ATTR_sched_preempt_order: &[u8; 14usize] = b"preempt_order\0";
pub const ATTR_sched_preempt_sort: &[u8; 13usize] = b"preempt_sort\0";
pub const ATTR_sched_server_dyn_res_alarm: &[u8; 21usize] = b"server_dyn_res_alarm\0";
pub const ATTR_NODE_Host: &[u8; 5usize] = b"Host\0";
pub const ATTR_NODE_Mom: &[u8; 4usize] = b"Mom\0";
pub const ATTR_NODE_Port: &[u8; 5usize] = b"Port\0";
pub const ATTR_NODE_state: &[u8; 6usize] = b"state\0";
pub const ATTR_NODE_ntype: &[u8; 6usize] = b"ntype\0";
pub const ATTR_NODE_jobs: &[u8; 5usize] = b"jobs\0";
pub const ATTR_NODE_resvs: &[u8; 5usize] = b"resv\0";
pub const ATTR_NODE_resv_enable: &[u8; 12usize] = b"resv_enable\0";
pub const ATTR_NODE_np: &[u8; 3usize] = b"np\0";
pub const ATTR_NODE_pcpus: &[u8; 6usize] = b"pcpus\0";
pub const ATTR_NODE_properties: &[u8; 11usize] = b"properties\0";
pub const ATTR_NODE_NoMultiNode: &[u8; 18usize] = b"no_multinode_jobs\0";
pub const ATTR_NODE_No_Tasks: &[u8; 9usize] = b"no_tasks\0";
pub const ATTR_NODE_Sharing: &[u8; 8usize] = b"sharing\0";
pub const ATTR_NODE_ProvisionEnable: &[u8; 17usize] = b"provision_enable\0";
pub const ATTR_NODE_current_aoe: &[u8; 12usize] = b"current_aoe\0";
pub const ATTR_NODE_in_multivnode_host: &[u8; 19usize] = b"in_multivnode_host\0";
pub const ATTR_NODE_License: &[u8; 8usize] = b"license\0";
pub const ATTR_NODE_LicenseInfo: &[u8; 13usize] = b"license_info\0";
pub const ATTR_NODE_TopologyInfo: &[u8; 14usize] = b"topology_info\0";
pub const ATTR_NODE_MaintJobs: &[u8; 17usize] = b"maintenance_jobs\0";
pub const ATTR_NODE_VnodePool: &[u8; 11usize] = b"vnode_pool\0";
pub const ATTR_NODE_current_eoe: &[u8; 12usize] = b"current_eoe\0";
pub const ATTR_NODE_power_provisioning: &[u8; 19usize] = b"power_provisioning\0";
pub const ATTR_NODE_poweroff_eligible: &[u8; 18usize] = b"poweroff_eligible\0";
pub const ATTR_NODE_last_state_change_time: &[u8; 23usize] = b"last_state_change_time\0";
pub const ATTR_NODE_last_used_time: &[u8; 15usize] = b"last_used_time\0";
pub const ND_RESC_LicSignature: &[u8; 14usize] = b"lic_signature\0";
pub const ATTR_RESC_TYPE: &[u8; 5usize] = b"type\0";
pub const ATTR_RESC_FLAG: &[u8; 5usize] = b"flag\0";
pub const CHECKPOINT_UNSPECIFIED: &[u8; 2usize] = b"u\0";
pub const NO_HOLD: &[u8; 2usize] = b"n\0";
pub const NO_JOIN: &[u8; 2usize] = b"n\0";
pub const NO_KEEP: &[u8; 2usize] = b"n\0";
pub const MAIL_AT_ABORT: &[u8; 2usize] = b"a\0";
pub const USER_HOLD: &[u8; 2usize] = b"u\0";
pub const OTHER_HOLD: &[u8; 2usize] = b"o\0";
pub const SYSTEM_HOLD: &[u8; 2usize] = b"s\0";
pub const BAD_PASSWORD_HOLD: &[u8; 2usize] = b"p\0";
pub const SITE_HOOK: &[u8; 5usize] = b"hook\0";
pub const PBS_HOOK: &[u8; 8usize] = b"pbshook\0";
pub const MSG_OUT: u32 = 1;
pub const MSG_ERR: u32 = 2;
pub const BLUEGENE: &[u8; 9usize] = b"bluegene\0";
pub const PBS_MAXHOSTNAME: u32 = 255;
pub const MAXPATHLEN: u32 = 1024;
pub const MAXNAMLEN: u32 = 255;
pub const PBS_MAXSCHEDNAME: u32 = 15;
pub const PBS_MAXUSER: u32 = 256;
pub const PBS_MAXPWLEN: u32 = 256;
pub const PBS_MAXGRPN: u32 = 256;
pub const PBS_MAXQUEUENAME: u32 = 15;
pub const PBS_MAXJOBNAME: u32 = 230;
pub const PBS_MAXSERVERNAME: u32 = 255;
pub const PBS_MAXSEQNUM: u32 = 12;
pub const PBS_DFLT_MAX_JOB_SEQUENCE_ID: u32 = 9999999;
pub const PBS_MAXPORTNUM: u32 = 5;
pub const PBS_MAXSVRJOBID: u32 = 273;
pub const PBS_MAXSVRRESVID: u32 = 274;
pub const PBS_MAXQRESVNAME: u32 = 15;
pub const PBS_MAXCLTJOBID: u32 = 535;
pub const PBS_MAXDEST: u32 = 256;
pub const PBS_MAXROUTEDEST: u32 = 277;
pub const PBS_INTERACTIVE: u32 = 1;
pub const PBS_TERM_BUF_SZ: u32 = 80;
pub const PBS_TERM_CCA: u32 = 6;
pub const PBS_RESV_ID_CHAR: u8 = 82u8;
pub const PBS_STDNG_RESV_ID_CHAR: u8 = 83u8;
pub const PBS_MNTNC_RESV_ID_CHAR: u8 = 77u8;
pub const PBS_AUTH_KEY_LEN: u32 = 129;
pub const SHUT_IMMEDIATE: u32 = 0;
pub const SHUT_DELAY: u32 = 1;
pub const SHUT_QUICK: u32 = 2;
pub const FORCE: &[u8; 6usize] = b"force\0";
pub const NOMAIL: &[u8; 7usize] = b"nomail\0";
pub const SUPPRESS_EMAIL: &[u8; 15usize] = b"suppress_email\0";
pub const DELETEHISTORY: &[u8; 11usize] = b"deletehist\0";
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbs_err_to_txt {
    pub err_no: ::std::os::raw::c_int,
    pub err_txt: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_pbs_err_to_txt() {
    assert_eq!(
        ::std::mem::size_of::<pbs_err_to_txt>(),
        16usize,
        concat!("Size of: ", stringify!(pbs_err_to_txt))
    );
    assert_eq!(
        ::std::mem::align_of::<pbs_err_to_txt>(),
        8usize,
        concat!("Alignment of ", stringify!(pbs_err_to_txt))
    );
    fn test_field_err_no() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pbs_err_to_txt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).err_no) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pbs_err_to_txt),
                "::",
                stringify!(err_no)
            )
        );
    }
    test_field_err_no();
    fn test_field_err_txt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pbs_err_to_txt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).err_txt) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(pbs_err_to_txt),
                "::",
                stringify!(err_txt)
            )
        );
    }
    test_field_err_txt();
}
extern "C" {
    pub fn pbse_to_txt(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __pbs_errno_location() -> *mut ::std::os::raw::c_int;
}
pub type size_t = ::std::os::raw::c_ulong;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__fsid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__fsid_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    fn test_field___wch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wch)
            )
        );
    }
    test_field___wch();
    fn test_field___wchb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wchb)
            )
        );
    }
    test_field___wchb();
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    fn test_field___count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__count)
            )
        );
    }
    test_field___count();
    fn test_field___value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__value)
            )
        );
    }
    test_field___value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    fn test_field___pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos_t),
                "::",
                stringify!(__pos)
            )
        );
    }
    test_field___pos();
    fn test_field___state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos_t),
                "::",
                stringify!(__state)
            )
        );
    }
    test_field___state();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    fn test_field___pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos64_t),
                "::",
                stringify!(__pos)
            )
        );
    }
    test_field___pos();
    fn test_field___state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos64_t),
                "::",
                stringify!(__state)
            )
        );
    }
    test_field___state();
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    fn test_field__next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_marker>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_marker),
                "::",
                stringify!(_next)
            )
        );
    }
    test_field__next();
    fn test_field__sbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_marker>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._sbuf) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_marker),
                "::",
                stringify!(_sbuf)
            )
        );
    }
    test_field__sbuf();
    fn test_field__pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_marker>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._pos) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_marker),
                "::",
                stringify!(_pos)
            )
        );
    }
    test_field__pos();
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    fn test_field__flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags)
            )
        );
    }
    test_field__flags();
    fn test_field__IO_read_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_ptr)
            )
        );
    }
    test_field__IO_read_ptr();
    fn test_field__IO_read_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_end)
            )
        );
    }
    test_field__IO_read_end();
    fn test_field__IO_read_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_base)
            )
        );
    }
    test_field__IO_read_base();
    fn test_field__IO_write_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_base)
            )
        );
    }
    test_field__IO_write_base();
    fn test_field__IO_write_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_ptr)
            )
        );
    }
    test_field__IO_write_ptr();
    fn test_field__IO_write_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_end)
            )
        );
    }
    test_field__IO_write_end();
    fn test_field__IO_buf_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_base)
            )
        );
    }
    test_field__IO_buf_base();
    fn test_field__IO_buf_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_end)
            )
        );
    }
    test_field__IO_buf_end();
    fn test_field__IO_save_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_base)
            )
        );
    }
    test_field__IO_save_base();
    fn test_field__IO_backup_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_backup_base)
            )
        );
    }
    test_field__IO_backup_base();
    fn test_field__IO_save_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_end)
            )
        );
    }
    test_field__IO_save_end();
    fn test_field__markers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_markers)
            )
        );
    }
    test_field__markers();
    fn test_field__chain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_chain)
            )
        );
    }
    test_field__chain();
    fn test_field__fileno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_fileno)
            )
        );
    }
    test_field__fileno();
    fn test_field__flags2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags2)
            )
        );
    }
    test_field__flags2();
    fn test_field__old_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_old_offset)
            )
        );
    }
    test_field__old_offset();
    fn test_field__cur_column() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_cur_column)
            )
        );
    }
    test_field__cur_column();
    fn test_field__vtable_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize
            },
            130usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_vtable_offset)
            )
        );
    }
    test_field__vtable_offset();
    fn test_field__shortbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize
            },
            131usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_shortbuf)
            )
        );
    }
    test_field__shortbuf();
    fn test_field__lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_lock)
            )
        );
    }
    test_field__lock();
    fn test_field__offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_offset)
            )
        );
    }
    test_field__offset();
    fn test_field___pad1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(__pad1)
            )
        );
    }
    test_field___pad1();
    fn test_field___pad2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(__pad2)
            )
        );
    }
    test_field___pad2();
    fn test_field___pad3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(__pad3)
            )
        );
    }
    test_field___pad3();
    fn test_field___pad4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(__pad4)
            )
        );
    }
    test_field___pad4();
    fn test_field___pad5() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(__pad5)
            )
        );
    }
    test_field___pad5();
    fn test_field__mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_mode)
            )
        );
    }
    test_field__mode();
    fn test_field__unused2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize
            },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_unused2)
            )
        );
    }
    test_field__unused2();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: size_t,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t)
        -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(
        arg1: *mut _IO_FILE,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_nsec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    test_field_tv_nsec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    fn test_field_tm_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_sec)
            )
        );
    }
    test_field_tm_sec();
    fn test_field_tm_min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_min)
            )
        );
    }
    test_field_tm_min();
    fn test_field_tm_hour() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_hour)
            )
        );
    }
    test_field_tm_hour();
    fn test_field_tm_mday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_mday)
            )
        );
    }
    test_field_tm_mday();
    fn test_field_tm_mon() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_mon)
            )
        );
    }
    test_field_tm_mon();
    fn test_field_tm_year() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_year)
            )
        );
    }
    test_field_tm_year();
    fn test_field_tm_wday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_wday)
            )
        );
    }
    test_field_tm_wday();
    fn test_field_tm_yday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_yday)
            )
        );
    }
    test_field_tm_yday();
    fn test_field_tm_isdst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_isdst)
            )
        );
    }
    test_field_tm_isdst();
    fn test_field_tm_gmtoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_gmtoff)
            )
        );
    }
    test_field_tm_gmtoff();
    fn test_field_tm_zone() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_zone)
            )
        );
    }
    test_field_tm_zone();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    fn test_field_it_interval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<itimerspec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(itimerspec),
                "::",
                stringify!(it_interval)
            )
        );
    }
    test_field_it_interval();
    fn test_field_it_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<itimerspec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(itimerspec),
                "::",
                stringify!(it_value)
            )
        );
    }
    test_field_it_value();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
pub type pid_t = __pid_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> size_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    fn test_field___locales() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__locales)
            )
        );
    }
    test_field___locales();
    fn test_field___ctype_b() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_b)
            )
        );
    }
    test_field___ctype_b();
    fn test_field___ctype_tolower() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_tolower)
            )
        );
    }
    test_field___ctype_tolower();
    fn test_field___ctype_toupper() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_toupper)
            )
        );
    }
    test_field___ctype_toupper();
    fn test_field___names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__names)
            )
        );
    }
    test_field___names();
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: __locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const mgr_cmd_MGR_CMD_NONE: mgr_cmd = -1;
pub const mgr_cmd_MGR_CMD_CREATE: mgr_cmd = 0;
pub const mgr_cmd_MGR_CMD_DELETE: mgr_cmd = 1;
pub const mgr_cmd_MGR_CMD_SET: mgr_cmd = 2;
pub const mgr_cmd_MGR_CMD_UNSET: mgr_cmd = 3;
pub const mgr_cmd_MGR_CMD_LIST: mgr_cmd = 4;
pub const mgr_cmd_MGR_CMD_PRINT: mgr_cmd = 5;
pub const mgr_cmd_MGR_CMD_ACTIVE: mgr_cmd = 6;
pub const mgr_cmd_MGR_CMD_IMPORT: mgr_cmd = 7;
pub const mgr_cmd_MGR_CMD_EXPORT: mgr_cmd = 8;
pub const mgr_cmd_MGR_CMD_LAST: mgr_cmd = 9;
pub type mgr_cmd = ::std::os::raw::c_int;
pub const mgr_obj_MGR_OBJ_NONE: mgr_obj = -1;
pub const mgr_obj_MGR_OBJ_SERVER: mgr_obj = 0;
pub const mgr_obj_MGR_OBJ_QUEUE: mgr_obj = 1;
pub const mgr_obj_MGR_OBJ_JOB: mgr_obj = 2;
pub const mgr_obj_MGR_OBJ_NODE: mgr_obj = 3;
pub const mgr_obj_MGR_OBJ_RESV: mgr_obj = 4;
pub const mgr_obj_MGR_OBJ_RSC: mgr_obj = 5;
pub const mgr_obj_MGR_OBJ_SCHED: mgr_obj = 6;
pub const mgr_obj_MGR_OBJ_HOST: mgr_obj = 7;
pub const mgr_obj_MGR_OBJ_HOOK: mgr_obj = 8;
pub const mgr_obj_MGR_OBJ_PBS_HOOK: mgr_obj = 9;
pub const mgr_obj_MGR_OBJ_LAST: mgr_obj = 10;
pub type mgr_obj = ::std::os::raw::c_int;
pub const batch_op_SET: batch_op = 0;
pub const batch_op_UNSET: batch_op = 1;
pub const batch_op_INCR: batch_op = 2;
pub const batch_op_DECR: batch_op = 3;
pub const batch_op_EQ: batch_op = 4;
pub const batch_op_NE: batch_op = 5;
pub const batch_op_GE: batch_op = 6;
pub const batch_op_GT: batch_op = 7;
pub const batch_op_LE: batch_op = 8;
pub const batch_op_LT: batch_op = 9;
pub const batch_op_DFLT: batch_op = 10;
pub type batch_op = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct attrl {
    pub next: *mut attrl,
    pub name: *mut ::std::os::raw::c_char,
    pub resource: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
    pub op: batch_op,
}
#[test]
fn bindgen_test_layout_attrl() {
    assert_eq!(
        ::std::mem::size_of::<attrl>(),
        40usize,
        concat!("Size of: ", stringify!(attrl))
    );
    assert_eq!(
        ::std::mem::align_of::<attrl>(),
        8usize,
        concat!("Alignment of ", stringify!(attrl))
    );
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<attrl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(attrl),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<attrl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(attrl),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_resource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<attrl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resource) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(attrl),
                "::",
                stringify!(resource)
            )
        );
    }
    test_field_resource();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<attrl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(attrl),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_op() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<attrl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).op) as usize - ptr as usize
            },
            32usize,
            concat!("Offset of field: ", stringify!(attrl), "::", stringify!(op))
        );
    }
    test_field_op();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct attropl {
    pub next: *mut attropl,
    pub name: *mut ::std::os::raw::c_char,
    pub resource: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
    pub op: batch_op,
}
#[test]
fn bindgen_test_layout_attropl() {
    assert_eq!(
        ::std::mem::size_of::<attropl>(),
        40usize,
        concat!("Size of: ", stringify!(attropl))
    );
    assert_eq!(
        ::std::mem::align_of::<attropl>(),
        8usize,
        concat!("Alignment of ", stringify!(attropl))
    );
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<attropl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(attropl),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<attropl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(attropl),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_resource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<attropl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resource) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(attropl),
                "::",
                stringify!(resource)
            )
        );
    }
    test_field_resource();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<attropl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(attropl),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_op() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<attropl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).op) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(attropl),
                "::",
                stringify!(op)
            )
        );
    }
    test_field_op();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct batch_status {
    pub next: *mut batch_status,
    pub name: *mut ::std::os::raw::c_char,
    pub attribs: *mut attrl,
    pub text: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_batch_status() {
    assert_eq!(
        ::std::mem::size_of::<batch_status>(),
        32usize,
        concat!("Size of: ", stringify!(batch_status))
    );
    assert_eq!(
        ::std::mem::align_of::<batch_status>(),
        8usize,
        concat!("Alignment of ", stringify!(batch_status))
    );
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<batch_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(batch_status),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<batch_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(batch_status),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_attribs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<batch_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attribs) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(batch_status),
                "::",
                stringify!(attribs)
            )
        );
    }
    test_field_attribs();
    fn test_field_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<batch_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(batch_status),
                "::",
                stringify!(text)
            )
        );
    }
    test_field_text();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecl_attrerr {
    pub ecl_attribute: *mut attropl,
    pub ecl_errcode: ::std::os::raw::c_int,
    pub ecl_errmsg: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ecl_attrerr() {
    assert_eq!(
        ::std::mem::size_of::<ecl_attrerr>(),
        24usize,
        concat!("Size of: ", stringify!(ecl_attrerr))
    );
    assert_eq!(
        ::std::mem::align_of::<ecl_attrerr>(),
        8usize,
        concat!("Alignment of ", stringify!(ecl_attrerr))
    );
    fn test_field_ecl_attribute() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ecl_attrerr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ecl_attribute) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ecl_attrerr),
                "::",
                stringify!(ecl_attribute)
            )
        );
    }
    test_field_ecl_attribute();
    fn test_field_ecl_errcode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ecl_attrerr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ecl_errcode) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ecl_attrerr),
                "::",
                stringify!(ecl_errcode)
            )
        );
    }
    test_field_ecl_errcode();
    fn test_field_ecl_errmsg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ecl_attrerr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ecl_errmsg) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ecl_attrerr),
                "::",
                stringify!(ecl_errmsg)
            )
        );
    }
    test_field_ecl_errmsg();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecl_attribute_errors {
    pub ecl_numerrors: ::std::os::raw::c_int,
    pub ecl_attrerr: *mut ecl_attrerr,
}
#[test]
fn bindgen_test_layout_ecl_attribute_errors() {
    assert_eq!(
        ::std::mem::size_of::<ecl_attribute_errors>(),
        16usize,
        concat!("Size of: ", stringify!(ecl_attribute_errors))
    );
    assert_eq!(
        ::std::mem::align_of::<ecl_attribute_errors>(),
        8usize,
        concat!("Alignment of ", stringify!(ecl_attribute_errors))
    );
    fn test_field_ecl_numerrors() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ecl_attribute_errors>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ecl_numerrors) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ecl_attribute_errors),
                "::",
                stringify!(ecl_numerrors)
            )
        );
    }
    test_field_ecl_numerrors();
    fn test_field_ecl_attrerr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ecl_attribute_errors>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ecl_attrerr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ecl_attribute_errors),
                "::",
                stringify!(ecl_attrerr)
            )
        );
    }
    test_field_ecl_attrerr();
}
pub const preempt_method_PREEMPT_METHOD_LOW: preempt_method = 0;
pub const preempt_method_PREEMPT_METHOD_SUSPEND: preempt_method = 1;
pub const preempt_method_PREEMPT_METHOD_CHECKPOINT: preempt_method = 2;
pub const preempt_method_PREEMPT_METHOD_REQUEUE: preempt_method = 3;
pub const preempt_method_PREEMPT_METHOD_DELETE: preempt_method = 4;
pub const preempt_method_PREEMPT_METHOD_HIGH: preempt_method = 5;
pub type preempt_method = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct preempt_job_info {
    pub job_id: [::std::os::raw::c_char; 274usize],
    pub order: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout_preempt_job_info() {
    assert_eq!(
        ::std::mem::size_of::<preempt_job_info>(),
        280usize,
        concat!("Size of: ", stringify!(preempt_job_info))
    );
    assert_eq!(
        ::std::mem::align_of::<preempt_job_info>(),
        1usize,
        concat!("Alignment of ", stringify!(preempt_job_info))
    );
    fn test_field_job_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<preempt_job_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).job_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(preempt_job_info),
                "::",
                stringify!(job_id)
            )
        );
    }
    test_field_job_id();
    fn test_field_order() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<preempt_job_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).order) as usize - ptr as usize
            },
            274usize,
            concat!(
                "Offset of field: ",
                stringify!(preempt_job_info),
                "::",
                stringify!(order)
            )
        );
    }
    test_field_order();
}
pub type pbs_resource_t = ::std::os::raw::c_int;
pub const resv_states_RESV_NONE: resv_states = 0;
pub const resv_states_RESV_UNCONFIRMED: resv_states = 1;
pub const resv_states_RESV_CONFIRMED: resv_states = 2;
pub const resv_states_RESV_WAIT: resv_states = 3;
pub const resv_states_RESV_TIME_TO_RUN: resv_states = 4;
pub const resv_states_RESV_RUNNING: resv_states = 5;
pub const resv_states_RESV_FINISHED: resv_states = 6;
pub const resv_states_RESV_BEING_DELETED: resv_states = 7;
pub const resv_states_RESV_DELETED: resv_states = 8;
pub const resv_states_RESV_DELETING_JOBS: resv_states = 9;
pub const resv_states_RESV_DEGRADED: resv_states = 10;
pub const resv_states_RESV_BEING_ALTERED: resv_states = 11;
pub const resv_states_RESV_IN_CONFLICT: resv_states = 12;
pub type resv_states = ::std::os::raw::c_uint;
extern "C" {
    pub fn __pbs_server_location() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pbs_asyrunjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_alterjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_asyalterjob(
        c: ::std::os::raw::c_int,
        jobid: *mut ::std::os::raw::c_char,
        attrib: *mut attrl,
        extend: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_confirmresv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_ulong,
        arg5: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_connect(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_connect_extend(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_disconnect(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_manager(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_char,
        arg5: *mut attropl,
        arg6: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_default() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pbs_deljob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_geterrmsg(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pbs_holdjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_loadconf(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_locjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pbs_movejob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_msgjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_char,
        arg5: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_relnodesjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_orderjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_rerunjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_rlsjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_runjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_selectjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut attropl,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pbs_sigjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_statfree(arg1: *mut batch_status);
}
extern "C" {
    pub fn pbs_statrsc(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_statjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_selstat(
        arg1: ::std::os::raw::c_int,
        arg2: *mut attropl,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_statque(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_statserver(
        arg1: ::std::os::raw::c_int,
        arg2: *mut attrl,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_statsched(
        arg1: ::std::os::raw::c_int,
        arg2: *mut attrl,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_stathost(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_statnode(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_statvnode(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_statresv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_stathook(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_get_attributes_in_error(arg1: ::std::os::raw::c_int) -> *mut ecl_attribute_errors;
}
extern "C" {
    pub fn pbs_submit(
        arg1: ::std::os::raw::c_int,
        arg2: *mut attropl,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
        arg5: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pbs_submit_resv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut attropl,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pbs_delresv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_terminate(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_modify_resv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attropl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pbs_preempt_jobs(
        arg1: ::std::os::raw::c_int,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> *mut preempt_job_info;
}
extern "C" {
    pub static mut pfn_pbs_asyrunjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_alterjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_asyalterjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_confirmresv: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_ulong,
            arg5: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_connect: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_connect_extend: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_char,
            arg2: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_default:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_char>;
}
extern "C" {
    pub static mut pfn_pbs_deljob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_disconnect: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_geterrmsg: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char,
    >;
}
extern "C" {
    pub static mut pfn_pbs_holdjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_loadconf: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_locjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >;
}
extern "C" {
    pub static mut pfn_pbs_manager: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut ::std::os::raw::c_char,
            arg5: *mut attropl,
            arg6: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_movejob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_msgjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: *mut ::std::os::raw::c_char,
            arg5: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_orderjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_rerunjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_rlsjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_runjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_selectjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut attropl,
            arg3: *mut ::std::os::raw::c_char,
        ) -> *mut *mut ::std::os::raw::c_char,
    >;
}
extern "C" {
    pub static mut pfn_pbs_sigjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_statfree:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut batch_status)>;
}
extern "C" {
    pub static mut pfn_pbs_statrsc: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_statjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_selstat: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut attropl,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_statque: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_statserver: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut attrl,
            arg3: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_statsched: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut attrl,
            arg3: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_stathost: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_statnode: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_statvnode: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_statresv: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_stathook: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_get_attributes_in_error: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> *mut ecl_attribute_errors,
    >;
}
extern "C" {
    pub static mut pfn_pbs_submit: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut attropl,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut ::std::os::raw::c_char,
            arg5: *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >;
}
extern "C" {
    pub static mut pfn_pbs_submit_resv: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut attropl,
            arg3: *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >;
}
extern "C" {
    pub static mut pfn_pbs_delresv: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_terminate: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_preempt_jobs: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut *mut ::std::os::raw::c_char,
        ) -> *mut preempt_job_info,
    >;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    fn test_field_gp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(gp_offset)
            )
        );
    }
    test_field_gp_offset();
    fn test_field_fp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(fp_offset)
            )
        );
    }
    test_field_fp_offset();
    fn test_field_overflow_arg_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(overflow_arg_area)
            )
        );
    }
    test_field_overflow_arg_area();
    fn test_field_reg_save_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(reg_save_area)
            )
        );
    }
    test_field_reg_save_area();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
